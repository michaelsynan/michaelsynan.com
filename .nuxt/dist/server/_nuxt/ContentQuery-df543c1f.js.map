{"version":3,"file":"ContentQuery-df543c1f.js","sources":["../../../../node_modules/.pnpm/nuxt@3.1.1/node_modules/nuxt/dist/app/composables/asyncData.mjs","../../../../node_modules/.pnpm/@nuxt+content@2.3.0/node_modules/@nuxt/content/dist/runtime/components/ContentQuery.vue"],"sourcesContent":["import { onBeforeMount, onServerPrefetch, onUnmounted, ref, getCurrentInstance, watch, unref, toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nimport { createError } from \"./error.mjs\";\nconst getDefault = () => null;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  let [key, handler, options = {}] = args;\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"[nuxt] [asyncData] key must be a string.\");\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [asyncData] handler must be a function.\");\n  }\n  options.server = options.server ?? true;\n  options.default = options.default ?? getDefault;\n  options.lazy = options.lazy ?? false;\n  options.immediate = options.immediate ?? true;\n  const nuxt = useNuxtApp();\n  const getCachedData = () => nuxt.isHydrating ? nuxt.payload.data[key] : nuxt.static.data[key];\n  const hasCachedData = () => getCachedData() !== void 0;\n  if (!nuxt._asyncData[key]) {\n    nuxt._asyncData[key] = {\n      data: ref(getCachedData() ?? options.default?.() ?? null),\n      pending: ref(!hasCachedData()),\n      error: ref(nuxt.payload._errors[key] ? createError(nuxt.payload._errors[key]) : null)\n    };\n  }\n  const asyncData = { ...nuxt._asyncData[key] };\n  asyncData.refresh = asyncData.execute = (opts = {}) => {\n    if (nuxt._asyncDataPromises[key]) {\n      if (opts.dedupe === false) {\n        return nuxt._asyncDataPromises[key];\n      }\n      nuxt._asyncDataPromises[key].cancelled = true;\n    }\n    if (opts._initial && hasCachedData()) {\n      return getCachedData();\n    }\n    asyncData.pending.value = true;\n    const promise = new Promise(\n      (resolve, reject) => {\n        try {\n          resolve(handler(nuxt));\n        } catch (err) {\n          reject(err);\n        }\n      }\n    ).then((result) => {\n      if (promise.cancelled) {\n        return nuxt._asyncDataPromises[key];\n      }\n      if (options.transform) {\n        result = options.transform(result);\n      }\n      if (options.pick) {\n        result = pick(result, options.pick);\n      }\n      asyncData.data.value = result;\n      asyncData.error.value = null;\n    }).catch((error) => {\n      if (promise.cancelled) {\n        return nuxt._asyncDataPromises[key];\n      }\n      asyncData.error.value = error;\n      asyncData.data.value = unref(options.default?.() ?? null);\n    }).finally(() => {\n      if (promise.cancelled) {\n        return;\n      }\n      asyncData.pending.value = false;\n      nuxt.payload.data[key] = asyncData.data.value;\n      if (asyncData.error.value) {\n        nuxt.payload._errors[key] = createError(asyncData.error.value);\n      }\n      delete nuxt._asyncDataPromises[key];\n    });\n    nuxt._asyncDataPromises[key] = promise;\n    return nuxt._asyncDataPromises[key];\n  };\n  const initialFetch = () => asyncData.refresh({ _initial: true });\n  const fetchOnServer = options.server !== false && nuxt.payload.serverRendered;\n  if (process.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxt.hook(\"app:created\", () => promise);\n    }\n  }\n  if (process.client) {\n    const instance = getCurrentInstance();\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      if (instance) {\n        onBeforeMount(() => {\n          cbs.forEach((cb) => {\n            cb();\n          });\n          cbs.splice(0, cbs.length);\n        });\n        onUnmounted(() => cbs.splice(0, cbs.length));\n      }\n    }\n    if (fetchOnServer && nuxt.isHydrating && hasCachedData()) {\n      asyncData.pending.value = false;\n    } else if (instance && (nuxt.payload.serverRendered && nuxt.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    if (options.watch) {\n      watch(options.watch, () => asyncData.refresh());\n    }\n    const off = nuxt.hook(\"app:data:refresh\", (keys) => {\n      if (!keys || keys.includes(key)) {\n        return asyncData.refresh();\n      }\n    });\n    if (instance) {\n      onUnmounted(off);\n    }\n  }\n  const asyncDataPromise = Promise.resolve(nuxt._asyncDataPromises[key]).then(() => asyncData);\n  Object.assign(asyncDataPromise, asyncData);\n  return asyncDataPromise;\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options] = args;\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nexport function useNuxtData(key) {\n  const nuxt = useNuxtApp();\n  if (!(key in nuxt.payload.data)) {\n    nuxt.payload.data[key] = null;\n  }\n  return {\n    data: toRef(nuxt.payload.data, key)\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (process.server) {\n    return Promise.resolve();\n  }\n  const _keys = keys ? Array.isArray(keys) ? keys : [keys] : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : Array.isArray(keys) ? keys : [keys];\n  for (const key of _keys) {\n    if (key in nuxtApp.payload.data) {\n      nuxtApp.payload.data[key] = void 0;\n    }\n    if (key in nuxtApp.payload._errors) {\n      nuxtApp.payload._errors[key] = void 0;\n    }\n    if (nuxtApp._asyncData[key]) {\n      nuxtApp._asyncData[key].data.value = void 0;\n      nuxtApp._asyncData[key].error.value = void 0;\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    if (key in nuxtApp._asyncDataPromises) {\n      nuxtApp._asyncDataPromises[key] = void 0;\n    }\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\n","<script>\nimport { hash } from \"ohash\";\nimport { toRefs, defineComponent, h, useSlots, watch } from \"vue\";\nimport { computed, useAsyncData, queryContent } from \"#imports\";\nexport default defineComponent({\n  name: \"ContentQuery\",\n  props: {\n    path: {\n      type: String,\n      required: false,\n      default: void 0\n    },\n    only: {\n      type: Array,\n      required: false,\n      default: void 0\n    },\n    without: {\n      type: Array,\n      required: false,\n      default: void 0\n    },\n    where: {\n      type: Object,\n      required: false,\n      default: void 0\n    },\n    sort: {\n      type: Object,\n      required: false,\n      default: void 0\n    },\n    limit: {\n      type: Number,\n      required: false,\n      default: void 0\n    },\n    skip: {\n      type: Number,\n      required: false,\n      default: void 0\n    },\n    locale: {\n      type: String,\n      required: false,\n      default: void 0\n    },\n    find: {\n      type: String,\n      required: false,\n      default: void 0\n    }\n  },\n  async setup(props) {\n    const {\n      path,\n      only,\n      without,\n      where,\n      sort,\n      limit,\n      skip,\n      locale,\n      find\n    } = toRefs(props);\n    const isPartial = computed(() => path.value?.includes(\"/_\"));\n    watch(() => props, () => refresh(), { deep: true });\n    const { data, refresh } = await useAsyncData(\n      `content-query-${hash(props)}`,\n      () => {\n        let queryBuilder;\n        if (path.value) {\n          queryBuilder = queryContent(path.value);\n        } else {\n          queryBuilder = queryContent();\n        }\n        if (only.value) {\n          queryBuilder = queryBuilder.only(only.value);\n        }\n        if (without.value) {\n          queryBuilder = queryBuilder.without(without.value);\n        }\n        if (where.value) {\n          queryBuilder = queryBuilder.where(where.value);\n        }\n        if (sort.value) {\n          queryBuilder = queryBuilder.sort(sort.value);\n        }\n        if (limit.value) {\n          queryBuilder = queryBuilder.limit(limit.value);\n        }\n        if (skip.value) {\n          queryBuilder = queryBuilder.skip(skip.value);\n        }\n        if (locale.value) {\n          queryBuilder = queryBuilder.where({ _locale: locale.value });\n        }\n        if (find.value === \"one\") {\n          return queryBuilder.findOne();\n        }\n        if (find.value === \"surround\") {\n          if (!path.value) {\n            console.warn(\"[Content] Surround queries requires `path` prop to be set.\");\n            console.warn(\"[Content] Query without `path` will return regular `find()` results.\");\n            return queryBuilder.find();\n          }\n          return queryBuilder.findSurround(path.value);\n        }\n        return queryBuilder.find();\n      }\n    );\n    return {\n      isPartial,\n      data,\n      refresh\n    };\n  },\n  render(ctx) {\n    const slots = useSlots();\n    const {\n      data,\n      refresh,\n      isPartial,\n      path,\n      only,\n      without,\n      where,\n      sort,\n      limit,\n      skip,\n      locale,\n      find\n    } = ctx;\n    const props = {\n      path,\n      only,\n      without,\n      where,\n      sort,\n      limit,\n      skip,\n      locale,\n      find\n    };\n    if (props.find === \"one\") {\n      if (!data && slots?.[\"not-found\"]) {\n        return slots[\"not-found\"]({ props, ...this.$attrs });\n      }\n      if (slots?.empty && data?._type === \"markdown\" && !data?.body?.children.length) {\n        return slots.empty({ props, ...this.$attrs });\n      }\n    } else if (!data || !data.length) {\n      if (slots?.[\"not-found\"]) {\n        return slots[\"not-found\"]({ props, ...this.$attrs });\n      }\n    }\n    if (slots?.default) {\n      return slots.default({ data, refresh, isPartial, props, ...this.$attrs });\n    }\n    const emptyNode = (slot, data2) => h(\"pre\", null, JSON.stringify({ message: \"You should use slots with <ContentQuery>!\", slot, data: data2 }, null, 2));\n    return emptyNode(\"default\", { data, props, isPartial });\n  }\n});\n</script>\n"],"names":["_a"],"mappings":"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"}